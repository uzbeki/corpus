# Generated by GitHub Copilot on 2026-01-25
from django.db import migrations


def _normalize_year(value):
    if value is None:
        return None

    # Already an int
    if isinstance(value, int):
        return value if 1 <= value <= 9999 else None

    # Date or datetime-like objects
    year_attr = getattr(value, "year", None)
    if isinstance(year_attr, int):
        return year_attr if 1 <= year_attr <= 9999 else None

    # Strings such as "2020-01-01" or "2020"
    if isinstance(value, str):
        val = value.strip()
        if not val:
            return None
        try:
            # Prefer the first 4 chars if they are digits (handles YYYY-MM-DD)
            if len(val) >= 4 and val[:4].isdigit():
                year_int = int(val[:4])
            else:
                year_int = int(val)
            return year_int if 1 <= year_int <= 9999 else None
        except ValueError:
            return None

    return None


def forwards(apps, schema_editor):
    Article = apps.get_model("main_app", "Article")
    Newspaper = apps.get_model("main_app", "Newspaper")

    for Model in (Article, Newspaper):
        for obj in Model.objects.all().iterator():
            current = getattr(obj, "published_year", None)
            normalized = _normalize_year(current)
            if normalized != current:
                setattr(obj, "published_year", normalized)
                obj.save(update_fields=["published_year"])


def reverse(apps, schema_editor):
    # No-op: we cannot reliably reconstruct full dates from a year-only field
    pass


class Migration(migrations.Migration):

    dependencies = [
        ("main_app", "0002_alter_article_published_year_and_more"),
    ]

    operations = [
        migrations.RunPython(forwards, reverse),
    ]
